// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package auth

import (
	"context"
	"sync"

	"github.com/minguu42/simoom/api/domain/model"
)

// Ensure, that AuthenticatorMock does implement Authenticator.
// If this is not the case, regenerate this file with moq.
var _ Authenticator = &AuthenticatorMock{}

// AuthenticatorMock is a mock implementation of Authenticator.
//
//	func TestSomethingThatUsesAuthenticator(t *testing.T) {
//
//		// make and configure a mocked Authenticator
//		mockedAuthenticator := &AuthenticatorMock{
//			CreateAccessTokenFunc: func(ctx context.Context, user model.User, secret string, expiry int) (string, error) {
//				panic("mock out the CreateAccessToken method")
//			},
//			CreateRefreshTokenFunc: func(ctx context.Context, user model.User, secret string, expiry int) (string, error) {
//				panic("mock out the CreateRefreshToken method")
//			},
//			ExtractIDFromTokenFunc: func(tokenString string, secret string) (string, error) {
//				panic("mock out the ExtractIDFromToken method")
//			},
//			IsAuthorizedFunc: func(tokenString string, secret string) (bool, error) {
//				panic("mock out the IsAuthorized method")
//			},
//		}
//
//		// use mockedAuthenticator in code that requires Authenticator
//		// and then make assertions.
//
//	}
type AuthenticatorMock struct {
	// CreateAccessTokenFunc mocks the CreateAccessToken method.
	CreateAccessTokenFunc func(ctx context.Context, user model.User, secret string, expiry int) (string, error)

	// CreateRefreshTokenFunc mocks the CreateRefreshToken method.
	CreateRefreshTokenFunc func(ctx context.Context, user model.User, secret string, expiry int) (string, error)

	// ExtractIDFromTokenFunc mocks the ExtractIDFromToken method.
	ExtractIDFromTokenFunc func(tokenString string, secret string) (string, error)

	// IsAuthorizedFunc mocks the IsAuthorized method.
	IsAuthorizedFunc func(tokenString string, secret string) (bool, error)

	// calls tracks calls to the methods.
	calls struct {
		// CreateAccessToken holds details about calls to the CreateAccessToken method.
		CreateAccessToken []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// User is the user argument value.
			User model.User
			// Secret is the secret argument value.
			Secret string
			// Expiry is the expiry argument value.
			Expiry int
		}
		// CreateRefreshToken holds details about calls to the CreateRefreshToken method.
		CreateRefreshToken []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// User is the user argument value.
			User model.User
			// Secret is the secret argument value.
			Secret string
			// Expiry is the expiry argument value.
			Expiry int
		}
		// ExtractIDFromToken holds details about calls to the ExtractIDFromToken method.
		ExtractIDFromToken []struct {
			// TokenString is the tokenString argument value.
			TokenString string
			// Secret is the secret argument value.
			Secret string
		}
		// IsAuthorized holds details about calls to the IsAuthorized method.
		IsAuthorized []struct {
			// TokenString is the tokenString argument value.
			TokenString string
			// Secret is the secret argument value.
			Secret string
		}
	}
	lockCreateAccessToken  sync.RWMutex
	lockCreateRefreshToken sync.RWMutex
	lockExtractIDFromToken sync.RWMutex
	lockIsAuthorized       sync.RWMutex
}

// CreateAccessToken calls CreateAccessTokenFunc.
func (mock *AuthenticatorMock) CreateAccessToken(ctx context.Context, user model.User, secret string, expiry int) (string, error) {
	if mock.CreateAccessTokenFunc == nil {
		panic("AuthenticatorMock.CreateAccessTokenFunc: method is nil but Authenticator.CreateAccessToken was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		User   model.User
		Secret string
		Expiry int
	}{
		Ctx:    ctx,
		User:   user,
		Secret: secret,
		Expiry: expiry,
	}
	mock.lockCreateAccessToken.Lock()
	mock.calls.CreateAccessToken = append(mock.calls.CreateAccessToken, callInfo)
	mock.lockCreateAccessToken.Unlock()
	return mock.CreateAccessTokenFunc(ctx, user, secret, expiry)
}

// CreateAccessTokenCalls gets all the calls that were made to CreateAccessToken.
// Check the length with:
//
//	len(mockedAuthenticator.CreateAccessTokenCalls())
func (mock *AuthenticatorMock) CreateAccessTokenCalls() []struct {
	Ctx    context.Context
	User   model.User
	Secret string
	Expiry int
} {
	var calls []struct {
		Ctx    context.Context
		User   model.User
		Secret string
		Expiry int
	}
	mock.lockCreateAccessToken.RLock()
	calls = mock.calls.CreateAccessToken
	mock.lockCreateAccessToken.RUnlock()
	return calls
}

// CreateRefreshToken calls CreateRefreshTokenFunc.
func (mock *AuthenticatorMock) CreateRefreshToken(ctx context.Context, user model.User, secret string, expiry int) (string, error) {
	if mock.CreateRefreshTokenFunc == nil {
		panic("AuthenticatorMock.CreateRefreshTokenFunc: method is nil but Authenticator.CreateRefreshToken was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		User   model.User
		Secret string
		Expiry int
	}{
		Ctx:    ctx,
		User:   user,
		Secret: secret,
		Expiry: expiry,
	}
	mock.lockCreateRefreshToken.Lock()
	mock.calls.CreateRefreshToken = append(mock.calls.CreateRefreshToken, callInfo)
	mock.lockCreateRefreshToken.Unlock()
	return mock.CreateRefreshTokenFunc(ctx, user, secret, expiry)
}

// CreateRefreshTokenCalls gets all the calls that were made to CreateRefreshToken.
// Check the length with:
//
//	len(mockedAuthenticator.CreateRefreshTokenCalls())
func (mock *AuthenticatorMock) CreateRefreshTokenCalls() []struct {
	Ctx    context.Context
	User   model.User
	Secret string
	Expiry int
} {
	var calls []struct {
		Ctx    context.Context
		User   model.User
		Secret string
		Expiry int
	}
	mock.lockCreateRefreshToken.RLock()
	calls = mock.calls.CreateRefreshToken
	mock.lockCreateRefreshToken.RUnlock()
	return calls
}

// ExtractIDFromToken calls ExtractIDFromTokenFunc.
func (mock *AuthenticatorMock) ExtractIDFromToken(tokenString string, secret string) (string, error) {
	if mock.ExtractIDFromTokenFunc == nil {
		panic("AuthenticatorMock.ExtractIDFromTokenFunc: method is nil but Authenticator.ExtractIDFromToken was just called")
	}
	callInfo := struct {
		TokenString string
		Secret      string
	}{
		TokenString: tokenString,
		Secret:      secret,
	}
	mock.lockExtractIDFromToken.Lock()
	mock.calls.ExtractIDFromToken = append(mock.calls.ExtractIDFromToken, callInfo)
	mock.lockExtractIDFromToken.Unlock()
	return mock.ExtractIDFromTokenFunc(tokenString, secret)
}

// ExtractIDFromTokenCalls gets all the calls that were made to ExtractIDFromToken.
// Check the length with:
//
//	len(mockedAuthenticator.ExtractIDFromTokenCalls())
func (mock *AuthenticatorMock) ExtractIDFromTokenCalls() []struct {
	TokenString string
	Secret      string
} {
	var calls []struct {
		TokenString string
		Secret      string
	}
	mock.lockExtractIDFromToken.RLock()
	calls = mock.calls.ExtractIDFromToken
	mock.lockExtractIDFromToken.RUnlock()
	return calls
}

// IsAuthorized calls IsAuthorizedFunc.
func (mock *AuthenticatorMock) IsAuthorized(tokenString string, secret string) (bool, error) {
	if mock.IsAuthorizedFunc == nil {
		panic("AuthenticatorMock.IsAuthorizedFunc: method is nil but Authenticator.IsAuthorized was just called")
	}
	callInfo := struct {
		TokenString string
		Secret      string
	}{
		TokenString: tokenString,
		Secret:      secret,
	}
	mock.lockIsAuthorized.Lock()
	mock.calls.IsAuthorized = append(mock.calls.IsAuthorized, callInfo)
	mock.lockIsAuthorized.Unlock()
	return mock.IsAuthorizedFunc(tokenString, secret)
}

// IsAuthorizedCalls gets all the calls that were made to IsAuthorized.
// Check the length with:
//
//	len(mockedAuthenticator.IsAuthorizedCalls())
func (mock *AuthenticatorMock) IsAuthorizedCalls() []struct {
	TokenString string
	Secret      string
} {
	var calls []struct {
		TokenString string
		Secret      string
	}
	mock.lockIsAuthorized.RLock()
	calls = mock.calls.IsAuthorized
	mock.lockIsAuthorized.RUnlock()
	return calls
}

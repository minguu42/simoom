// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package auth

import (
	"context"
	"sync"

	"github.com/minguu42/simoom/api/domain/model"
)

// Ensure, that AuthenticatorMock does implement Authenticator.
// If this is not the case, regenerate this file with moq.
var _ Authenticator = &AuthenticatorMock{}

// AuthenticatorMock is a mock implementation of Authenticator.
//
//	func TestSomethingThatUsesAuthenticator(t *testing.T) {
//
//		// make and configure a mocked Authenticator
//		mockedAuthenticator := &AuthenticatorMock{
//			CreateAccessTokenFunc: func(ctx context.Context, user model.User) (string, error) {
//				panic("mock out the CreateAccessToken method")
//			},
//			CreateRefreshTokenFunc: func(ctx context.Context, user model.User) (string, error) {
//				panic("mock out the CreateRefreshToken method")
//			},
//			ExtractIDFromRefreshTokenFunc: func(tokenString string) (string, error) {
//				panic("mock out the ExtractIDFromRefreshToken method")
//			},
//			ExtractIDFromTokenFunc: func(tokenString string) (string, error) {
//				panic("mock out the ExtractIDFromToken method")
//			},
//			IsAuthorizedFunc: func(tokenString string) (bool, error) {
//				panic("mock out the IsAuthorized method")
//			},
//		}
//
//		// use mockedAuthenticator in code that requires Authenticator
//		// and then make assertions.
//
//	}
type AuthenticatorMock struct {
	// CreateAccessTokenFunc mocks the CreateAccessToken method.
	CreateAccessTokenFunc func(ctx context.Context, user model.User) (string, error)

	// CreateRefreshTokenFunc mocks the CreateRefreshToken method.
	CreateRefreshTokenFunc func(ctx context.Context, user model.User) (string, error)

	// ExtractIDFromRefreshTokenFunc mocks the ExtractIDFromRefreshToken method.
	ExtractIDFromRefreshTokenFunc func(tokenString string) (string, error)

	// ExtractIDFromTokenFunc mocks the ExtractIDFromToken method.
	ExtractIDFromTokenFunc func(tokenString string) (string, error)

	// IsAuthorizedFunc mocks the IsAuthorized method.
	IsAuthorizedFunc func(tokenString string) (bool, error)

	// calls tracks calls to the methods.
	calls struct {
		// CreateAccessToken holds details about calls to the CreateAccessToken method.
		CreateAccessToken []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// User is the user argument value.
			User model.User
		}
		// CreateRefreshToken holds details about calls to the CreateRefreshToken method.
		CreateRefreshToken []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// User is the user argument value.
			User model.User
		}
		// ExtractIDFromRefreshToken holds details about calls to the ExtractIDFromRefreshToken method.
		ExtractIDFromRefreshToken []struct {
			// TokenString is the tokenString argument value.
			TokenString string
		}
		// ExtractIDFromToken holds details about calls to the ExtractIDFromToken method.
		ExtractIDFromToken []struct {
			// TokenString is the tokenString argument value.
			TokenString string
		}
		// IsAuthorized holds details about calls to the IsAuthorized method.
		IsAuthorized []struct {
			// TokenString is the tokenString argument value.
			TokenString string
		}
	}
	lockCreateAccessToken         sync.RWMutex
	lockCreateRefreshToken        sync.RWMutex
	lockExtractIDFromRefreshToken sync.RWMutex
	lockExtractIDFromToken        sync.RWMutex
	lockIsAuthorized              sync.RWMutex
}

// CreateAccessToken calls CreateAccessTokenFunc.
func (mock *AuthenticatorMock) CreateAccessToken(ctx context.Context, user model.User) (string, error) {
	if mock.CreateAccessTokenFunc == nil {
		panic("AuthenticatorMock.CreateAccessTokenFunc: method is nil but Authenticator.CreateAccessToken was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		User model.User
	}{
		Ctx:  ctx,
		User: user,
	}
	mock.lockCreateAccessToken.Lock()
	mock.calls.CreateAccessToken = append(mock.calls.CreateAccessToken, callInfo)
	mock.lockCreateAccessToken.Unlock()
	return mock.CreateAccessTokenFunc(ctx, user)
}

// CreateAccessTokenCalls gets all the calls that were made to CreateAccessToken.
// Check the length with:
//
//	len(mockedAuthenticator.CreateAccessTokenCalls())
func (mock *AuthenticatorMock) CreateAccessTokenCalls() []struct {
	Ctx  context.Context
	User model.User
} {
	var calls []struct {
		Ctx  context.Context
		User model.User
	}
	mock.lockCreateAccessToken.RLock()
	calls = mock.calls.CreateAccessToken
	mock.lockCreateAccessToken.RUnlock()
	return calls
}

// CreateRefreshToken calls CreateRefreshTokenFunc.
func (mock *AuthenticatorMock) CreateRefreshToken(ctx context.Context, user model.User) (string, error) {
	if mock.CreateRefreshTokenFunc == nil {
		panic("AuthenticatorMock.CreateRefreshTokenFunc: method is nil but Authenticator.CreateRefreshToken was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		User model.User
	}{
		Ctx:  ctx,
		User: user,
	}
	mock.lockCreateRefreshToken.Lock()
	mock.calls.CreateRefreshToken = append(mock.calls.CreateRefreshToken, callInfo)
	mock.lockCreateRefreshToken.Unlock()
	return mock.CreateRefreshTokenFunc(ctx, user)
}

// CreateRefreshTokenCalls gets all the calls that were made to CreateRefreshToken.
// Check the length with:
//
//	len(mockedAuthenticator.CreateRefreshTokenCalls())
func (mock *AuthenticatorMock) CreateRefreshTokenCalls() []struct {
	Ctx  context.Context
	User model.User
} {
	var calls []struct {
		Ctx  context.Context
		User model.User
	}
	mock.lockCreateRefreshToken.RLock()
	calls = mock.calls.CreateRefreshToken
	mock.lockCreateRefreshToken.RUnlock()
	return calls
}

// ExtractIDFromRefreshToken calls ExtractIDFromRefreshTokenFunc.
func (mock *AuthenticatorMock) ExtractIDFromRefreshToken(tokenString string) (string, error) {
	if mock.ExtractIDFromRefreshTokenFunc == nil {
		panic("AuthenticatorMock.ExtractIDFromRefreshTokenFunc: method is nil but Authenticator.ExtractIDFromRefreshToken was just called")
	}
	callInfo := struct {
		TokenString string
	}{
		TokenString: tokenString,
	}
	mock.lockExtractIDFromRefreshToken.Lock()
	mock.calls.ExtractIDFromRefreshToken = append(mock.calls.ExtractIDFromRefreshToken, callInfo)
	mock.lockExtractIDFromRefreshToken.Unlock()
	return mock.ExtractIDFromRefreshTokenFunc(tokenString)
}

// ExtractIDFromRefreshTokenCalls gets all the calls that were made to ExtractIDFromRefreshToken.
// Check the length with:
//
//	len(mockedAuthenticator.ExtractIDFromRefreshTokenCalls())
func (mock *AuthenticatorMock) ExtractIDFromRefreshTokenCalls() []struct {
	TokenString string
} {
	var calls []struct {
		TokenString string
	}
	mock.lockExtractIDFromRefreshToken.RLock()
	calls = mock.calls.ExtractIDFromRefreshToken
	mock.lockExtractIDFromRefreshToken.RUnlock()
	return calls
}

// ExtractIDFromToken calls ExtractIDFromTokenFunc.
func (mock *AuthenticatorMock) ExtractIDFromToken(tokenString string) (string, error) {
	if mock.ExtractIDFromTokenFunc == nil {
		panic("AuthenticatorMock.ExtractIDFromTokenFunc: method is nil but Authenticator.ExtractIDFromToken was just called")
	}
	callInfo := struct {
		TokenString string
	}{
		TokenString: tokenString,
	}
	mock.lockExtractIDFromToken.Lock()
	mock.calls.ExtractIDFromToken = append(mock.calls.ExtractIDFromToken, callInfo)
	mock.lockExtractIDFromToken.Unlock()
	return mock.ExtractIDFromTokenFunc(tokenString)
}

// ExtractIDFromTokenCalls gets all the calls that were made to ExtractIDFromToken.
// Check the length with:
//
//	len(mockedAuthenticator.ExtractIDFromTokenCalls())
func (mock *AuthenticatorMock) ExtractIDFromTokenCalls() []struct {
	TokenString string
} {
	var calls []struct {
		TokenString string
	}
	mock.lockExtractIDFromToken.RLock()
	calls = mock.calls.ExtractIDFromToken
	mock.lockExtractIDFromToken.RUnlock()
	return calls
}

// IsAuthorized calls IsAuthorizedFunc.
func (mock *AuthenticatorMock) IsAuthorized(tokenString string) (bool, error) {
	if mock.IsAuthorizedFunc == nil {
		panic("AuthenticatorMock.IsAuthorizedFunc: method is nil but Authenticator.IsAuthorized was just called")
	}
	callInfo := struct {
		TokenString string
	}{
		TokenString: tokenString,
	}
	mock.lockIsAuthorized.Lock()
	mock.calls.IsAuthorized = append(mock.calls.IsAuthorized, callInfo)
	mock.lockIsAuthorized.Unlock()
	return mock.IsAuthorizedFunc(tokenString)
}

// IsAuthorizedCalls gets all the calls that were made to IsAuthorized.
// Check the length with:
//
//	len(mockedAuthenticator.IsAuthorizedCalls())
func (mock *AuthenticatorMock) IsAuthorizedCalls() []struct {
	TokenString string
} {
	var calls []struct {
		TokenString string
	}
	mock.lockIsAuthorized.RLock()
	calls = mock.calls.IsAuthorized
	mock.lockIsAuthorized.RUnlock()
	return calls
}

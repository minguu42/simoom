// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: task_query.sql

package sqlc

import (
	"context"
	"database/sql"
	"time"
)

const createTask = `-- name: CreateTask :exec
INSERT INTO task (id, user_id, project_id, title, content, priority, due_on, completed_at, created_at, updated_at)
VALUES (?, ?, ?, ?, '', ?, NULL, NULL, ?, ?)
`

type CreateTaskParams struct {
	ID        string
	UserID    string
	ProjectID string
	Title     string
	Priority  uint32
	CreatedAt time.Time
	UpdatedAt time.Time
}

func (q *Queries) CreateTask(ctx context.Context, arg CreateTaskParams) error {
	_, err := q.db.ExecContext(ctx, createTask,
		arg.ID,
		arg.UserID,
		arg.ProjectID,
		arg.Title,
		arg.Priority,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	return err
}

const deleteTask = `-- name: DeleteTask :exec
DELETE
FROM task
WHERE id = ?
`

func (q *Queries) DeleteTask(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteTask, id)
	return err
}

const getTaskByID = `-- name: GetTaskByID :one
SELECT t.id, t.user_id, t.project_id, t.title, t.content, t.priority, t.due_on, t.completed_at, t.created_at, t.updated_at,
       s.id           AS step_id,
       s.user_id      AS step_user_id,
       s.task_id      AS step_task_id,
       s.title        AS step_title,
       s.completed_at AS step_completed_at,
       s.created_at   AS step_created_at,
       s.updated_at   AS step_updated_at
FROM task AS t
       INNER JOIN step AS s ON t.id = s.task_id
WHERE t.id = ?
`

type GetTaskByIDRow struct {
	ID              string
	UserID          string
	ProjectID       string
	Title           string
	Content         string
	Priority        uint32
	DueOn           sql.NullTime
	CompletedAt     sql.NullTime
	CreatedAt       time.Time
	UpdatedAt       time.Time
	StepID          string
	StepUserID      string
	StepTaskID      string
	StepTitle       string
	StepCompletedAt sql.NullTime
	StepCreatedAt   time.Time
	StepUpdatedAt   time.Time
}

func (q *Queries) GetTaskByID(ctx context.Context, id string) (GetTaskByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getTaskByID, id)
	var i GetTaskByIDRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ProjectID,
		&i.Title,
		&i.Content,
		&i.Priority,
		&i.DueOn,
		&i.CompletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.StepID,
		&i.StepUserID,
		&i.StepTaskID,
		&i.StepTitle,
		&i.StepCompletedAt,
		&i.StepCreatedAt,
		&i.StepUpdatedAt,
	)
	return i, err
}

const listTasksByProjectID = `-- name: ListTasksByProjectID :many
SELECT id, user_id, project_id, title, content, priority, due_on, completed_at, created_at, updated_at
FROM task
WHERE project_id = ?
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type ListTasksByProjectIDParams struct {
	ProjectID string
	Limit     int32
	Offset    int32
}

func (q *Queries) ListTasksByProjectID(ctx context.Context, arg ListTasksByProjectIDParams) ([]Task, error) {
	rows, err := q.db.QueryContext(ctx, listTasksByProjectID, arg.ProjectID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Task
	for rows.Next() {
		var i Task
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ProjectID,
			&i.Title,
			&i.Content,
			&i.Priority,
			&i.DueOn,
			&i.CompletedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTask = `-- name: UpdateTask :exec
UPDATE task
SET title        = ?,
    content      = ?,
    priority     = ?,
    due_on       = ?,
    completed_at = ?
WHERE id = ?
`

type UpdateTaskParams struct {
	Title       string
	Content     string
	Priority    uint32
	DueOn       sql.NullTime
	CompletedAt sql.NullTime
	ID          string
}

func (q *Queries) UpdateTask(ctx context.Context, arg UpdateTaskParams) error {
	_, err := q.db.ExecContext(ctx, updateTask,
		arg.Title,
		arg.Content,
		arg.Priority,
		arg.DueOn,
		arg.CompletedAt,
		arg.ID,
	)
	return err
}
